<!-- GFM-TOC -->

* [ZooKeeper介绍](#zookeeper介绍)
    * [1. 分布式协调技术](#1-分布式协调技术)
      * [1.1 分布式系统概述](#11-分布式系统概述)
      * [1.2 分布式锁概述](#12-分布式锁概述)
    * [2. 分布式锁的实现](#2-分布式锁的实现)
    * [3. Zookeeper概述](#3-zookeeper概述)
    * [4. Zookeeper数据模型](#4-zookeeper数据模型)
      * [4.1 Zookeeper数据模型-ZNode](#41-zookeeper数据模型-znode)
        * [4.1.1 引用方式](#411-引用方式)
        * [4.1.2 Znode结构](#412-znode结构)
        * [4.1.3 数据访问](#413-数据访问)
        * [4.1.4 节点类型](#414-节点类型)
        * [4.1.5 顺序节点](#415-顺序节点)
        * [4.1.6 观察](#416-观察)
      * [4.2 ZooKeeper中的时间](#42-zookeeper中的时间)
      * [4.3 ZooKeeper节点属性](#43-zookeeper节点属性)
    * [5.ZooKeeper服务中操作](#5-zookeeper服务中操作)
    * [6. Watch触发器](#6-watch触发器)
      * [6.1 watch概述](#61-watch概述)
      * [6.2 watch类型](#62-watch类型)
    * [7. ZooKeeper应用举例](#7-zookeeper应用举例)
      * [7.1 分布式锁应用场景](#71-分布式锁应用场景)
      * [7.2 传统解决方案](#72-传统解决方案)
      * [7.3 ZooKeeper解决方案](#73-zookeeper解决方案)
<!-- GFM-TOC -->
# ZooKeeper介绍
```
  zookeeper 学习资源:http://www.cnblogs.com/sunddenly/category/620563.html
```
## 1. 分布式协调技术
```
  分布式协调技术主要用来解决分布式环境中多个进程之间的同步控制,让他们有序的去访问某种临界资源,防止造成"脏数据"的后果.
```
![](https://images0.cnblogs.com/blog/671563/201411/301534548096997.png)
### 1.1 分布式系统概述
 - 分布式系统:
``` 
如上图中,三台机器,每台机器各跑一个程序,然后通过网络将三个节点构建成一个系统为用户提供服务,我们称这种系统为分布式系统;
```
### 1.2 分布式锁概述
 - 分布式锁:
```
  在上述分布式系统中如何对进程进行调度,我假设在第一台机器上挂载一个资源,然后这三个物理分布的进程都要竞争这个资源,但我们又不希望他们同时访问,这时候我们就需要一个协调器,来让他们有序地来访问这个资源。这个协调器就是我们经常提到的"锁",我们通过锁机制来保证分布式系统中多个进程能够有序地访问临界区资源，我们把这种在分布式环境下的锁称之为分布式锁;分布式锁也是分布式协调技术实现的核心内容;
```
 - 分布式锁主要用于在分布式环境中保护跨进程,跨主机,跨网络的共享资源实现互斥访问,以达到保证数据的一致性;
 

## 2. 分布式锁的实现
```
   分布式锁: http://blog.csdn.net/sunfeizhi/article/details/51926396
   http://blog.csdn.net/peace1213/article/details/52571445
```
## 3. Zookeeper概述
 - ZK可以干什么?
ZooKeeper是一种为分布式应用所设计的高可用,高性能且一致的开源协调服务,它提供了一项基本服务:分布式锁。我们在其分布式锁的基础上摸索出: 
 ```
   配置维护,组服务,分布式消息队列,分布式通知/协调等;
 ```
 - ZooKeeper 性能上的特点决定了它能够用在大型的,分布式的系统中.从可靠性方面来说,它并不会因为一个节点的宕机而崩溃.除此之外,它严格的序列访问控制意味着复杂的控制原语可以应用在客户端上.Zookeeper在一致性,可用性,容错性上的保证,也是zookeeper的成功之处.它的成功奥秘在---Zab协议;
 - ZooKeeper所提供的服务主要是通过：数据结构+原语+watcher机制，三个部分来实现的。那么我就从这三个方面，给大家介绍一下ZooKeeper

## 4. Zookeeper数据模型
### 4.1 Zookeeper数据模型-ZNode
![](https://images0.cnblogs.com/blog/671563/201411/301534562152768.png)
```
  ZK数据模型在结构和标准文件系统的非常相似，ZK树中的每一个节点被称为-ZNode;
```
#### 4.1.1 引用方式
```
   Zonde通过路径引用，如同Unix中的文件路径。路径必须是绝对的，因此他们必须由斜杠字符来开头。除此以外，他们必须是唯一的，也就是说每一个路径只有一个表示，因此这些路径不能改变。在ZooKeeper中，路径由Unicode字符串组成，并且有一些限制。字符串"/zookeeper"用以保存管理信息，比如关键配额信息。
```
#### 4.1.2 Znode结构
```
   兼具文件和目录两种特点.即像文件一样维护着数据,元信息,ACL,时间戳等数据结构，又像目录一样作为路径标识的一部分.
```
   每一个ZNODE节点由三部分组成 :
   -  stat: 此为状态信息,描述该Znode的版本,权限等信息;
   -  data: 与该Znode关联的数据;
   -  children : 该Znode下的子节点;
```
ZooKeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。ZooKeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，但常规使用中应该远小于此值。
```
#### 4.1.3 数据访问
```
  ZooKeeper中的每个节点存储的数据要被原子性的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。
```
#### 4.1.4 节点类型
 - 临时节点
```
  该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，ZooKeeper的临时节点不允许拥有子节点。
```
 - 永久节点
```
  该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。
```
#### 4.1.5 顺序节点
```
   当创建Znode的时候，用户可以请求在ZooKeeper的路径结尾添加一个递增的计数。这个计数对于此节点的父节点来说是唯一的，它的格式为"%10d"(10位数字，没有数值的数位用0补充，例如"0000000001")。当计数值大于232-1时，计数器将溢出。
```
#### 4.1.6 观察
```
  客户端可以在节点上设置watch，我们称之为监视器。当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作。当watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次，这样可以减少网络流量。
```
### 4.2 ZooKeeper中的时间
```
 ZooKeeper有多种记录时间的形式,其中包含以下几个主要属性:
```
 - Zxid
```
  致使ZooKeeper节点状态改变的每一个操作都将节点接收到一个Zxid格式的时间戳,并且这个时间戳全局有序。也就是说，也就是说，每个对节点的改变都将产生一个唯一的Zxid。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。实际上，ZooKeeper的每个节点维护着三个Zxid值，为别为：cZxid、mZxid、pZxid。
```
 - 版本号
```
  对节点的每一个操作都将致使这个节点的版本号增加.每个节点维护着三个版本号,他们分别为:
```
 [1] version:节点数据版本号</br>
 [2] cversion: 子节点版本号</br>
 [3] aversion: 节点拥有的ACL版本号
### 4.3 ZooKeeper节点属性
```
  一个节点自身拥有表示其状态的许多重要属性;
```
![](https://images0.cnblogs.com/blog/671563/201411/301534569026625.png)
## 5. ZooKeeper服务中操作
```
  在ZooKeeper中有9个基本操作,如下图所示:
```
![](https://images0.cnblogs.com/blog/671563/201411/301534572468352.png)
```
  更新ZooKeeper操作是有限制的.delete或setData必须明确更新的Znode版本号,我们可以调用exists方法找到.如果版本号不匹配,更新将会失败;
```
```
  更新ZooKeeper操作时非阻塞式的.因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode),他可以在不阻塞其他进程执行的情况下,选择重试尝试或进行其他操作.
```
```
  尽管ZooKeeper可以被看做是一个文件系统,但是处于便利,摒弃了一些文件系统的操作原语.因为文件非常的小并且使整体读写的,所以不需要打开,关闭等操作;
```
## 6. Watch触发器
### 6.1 watch概述
```
   ZooKeeper可以为所有的读操作设置watch,这些读操作包括: exists(),getChildren()以及getData().watch事件是一次性的触发器,当watch的对象状态发生改变时,将会触发此对象上watch所对应的事件.watch事件将被异步地发送给客户端,并且ZooKeeper为watch机制提供了有序地一致性保证.理论上,客户端接受watch事件的事件要快于其看到watch对象状态变化的时间.
```
### 6.2 watch类型
ZooKeeper所管理的watch可以分为两类:
 - 数据watch(data watches): getData和exists负责设置数据watch;
 - 孩子watch(child watches): getChildren负责设置孩子watch;

我们可以通过操作返回数据来设置不同的watch:
 - getData和exists:返回关于节点的数据信息;
 - getChildren:返回孩子列表;

因此,
 - 一个成功的setData操作将会触发ZNode的数据watch;
 - 一个成功的create操作将会触发ZNode的数据watch以及孩子watch;
 - 一个成功的delete操作将触发ZNode的数据watch以及孩子watch;

## 7. ZooKeeper应用举例
### 7.1 分布式锁应用场景
在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行Master选举，来解决分布式系统中的单点故障。什么是分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。如下图7.1和7.2所示:

![](https://images0.cnblogs.com/blog/671563/201411/301534587316566.png)</br>

![](https://images0.cnblogs.com/blog/671563/201411/301534591214279.png)</br>
### 7.2 传统解决方案
传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送ping包，主节点收到ping包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。如图7.3所示：

![](https://images0.cnblogs.com/blog/671563/201411/301534594814937.png)</br>

当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点,如下图7.4所示:

![](https://images0.cnblogs.com/blog/671563/201411/301534599495094.png)</br>
但是这种方式就是有一个隐患，就是网络问题，来看一网络问题会造成什么后果，如下图7.5所示:

![](https://images0.cnblogs.com/blog/671563/201411/301535005121522.png)</br>
也就是说我们的主节点的并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是---双Master，出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。为了防止出现这种情况，我们引入了ZooKeeper，它虽然不能避免网络故障，但它能够保证每时每刻只有一个Master。我么来看一下ZooKeeper是如何实现的。
### 7.3 ZooKeeper解决方案
 - Master启动
 
在引入了Zookeeper以后我们启动了两个主节点，"主节点-A"和"主节点-B"他们启动以后，都向ZooKeeper去注册一个节点。我们假设"主节点-A"锁注册地节点是"master-00001"，"主节点-B"注册的节点是"master-00002"，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的"主节点-A"将会获得锁成为主节点，然后"主节点-B"将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个Master进程的调度

![](https://images0.cnblogs.com/blog/671563/201411/301535008567950.png)</br>
 - Master故障

如果"主节点-A"挂了，这时候他所注册的节点将被自动删除，ZooKeeper会自动感知节点的变化，然后再次发出选举，这时候"主节点-B"将在选举中获胜，替代"主节点-A"成为主节点.
![](https://images0.cnblogs.com/blog/671563/201411/301535012773122.png)</br>

 - Master恢复

![](https://images0.cnblogs.com/blog/671563/201411/301535016997293.png)</br>
```
如果主节点恢复了，他会再次向ZooKeeper注册一个节点，这时候他注册的节点将会是"master-00003"，ZooKeeper会感知节点的变化再次发动选举，这时候"主节点-B"在选举中会再次获胜继续担任"主节点"，"主节点-A"会担任备用节点。
```



