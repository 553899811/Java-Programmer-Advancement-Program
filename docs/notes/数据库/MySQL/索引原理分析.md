# 索引原理分析

 - BTree索引
 - B+Tree索引
 - 哈希索引
 - 全文索引
## 1.1 哈希索引
只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引<font color='red'>**不支持范围查找和排序的功能。**</font>
## 1.2 全文索引
  FULLTEXT（全文）索引，仅可用于MyISAM和InnoDB，针对较大的数据，生成全文索引非常的消耗时间和空间。对于文本的大对象，或者较大的CHAR类型的数据，如果使用普通索引，那么匹配文本前几个字符还是可行的，但是想要匹配文本中间的几个单词，那么就要使用LIKE %word%来匹配，这样需要很长的时间来处理，响应时间会大大增加，这种情况，就可使用时FULLTEXT索引了，在生成FULLTEXT索引时，会为文本生成一份单词的清单，在索引时及根据这个单词的清单来索引。FULLTEXT可以在创建表的时候创建，也可以在需要的时候用ALTER或者CREATE INDEX来添加：
```
  //创建表的时候添加FULLTEXT索引
CTREATE TABLE my_table(
    id INT(10) PRIMARY KEY,
    name VARCHAR(10) NOT NULL,
    my_text TEXT,
    FULLTEXT(my_text)
)ENGINE=MyISAM DEFAULT CHARSET=utf8;

```
 - 全文索引的查询也有自己特殊的语法，而不能使用LIKE %查询字符串%的模糊查询语法
 ```
   SELECT * FROM table_name MATCH(ft_index) AGAINST('查询字符串');
 ```
 
 ## 1.3 BTree索引
 ![](/about/media/pic/btree.png)
BTree是平衡搜索多叉树，设树的度为2d（d>1），高度为h，那么BTree要满足以以下条件:
 - 每个叶子结点的高度一样，等于h;
 - 每个非叶子结点由n-1个key和n个指针point组成，其中d<=n<=2d,key和point相互间隔，结点两端一定是key;
 - 叶子结点指针都为null;
 - 非叶子结点的key都是[key,data]二元组，其中key表示作为索引的键，data为键值所在行的数据;

### 1.3.1 模拟BTree查询过程
 ![](/about/media/pic/btree查询过程.jpg)
- 来模拟下查找文件29的过程

  (1) 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】

  (2) 此时内存中有两个文件名17，35和三个存储其他磁盘页面地址的数据。根据算法我们发现17<29<35，因此我们找到指针p2。

  (3) 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作2次】

  (4) 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现26<29<30，因此我们找到指针p2。

  (5) 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存 【磁盘IO操作3次】

  (6) 此时内存中有两个文件名28，29。根据算法我们查找到文件29，并定位了该文件内存的磁盘地址;

 ### 1.3.2 BTree插入操作
 [BTree插入操作演示](https://blog.csdn.net/endlu/article/details/51720299)


## 1.4 B+Tree索引
 ![](/about/media/pic/bplustree.png)
B+Tree是BTree的一个变种，设d为树的度数，h为树的高度，B+Tree和BTree的不同主要在于:
 - B+Tree中的非叶子结点不存储数据，只存储键值；
 - B+Tree的叶子结点没有指针，所有键值都会出现在叶子结点上，且key存储的键值对应data数据的物理地址；
 - B+Tree的每个非叶子节点由n个键值key和n个指针point组成;

 ### 1.4.1 B+Tree 索引 是如何支撑千万级表的快速查询
  [1] 查看mysql文件页的大小
  ```
     SHOW GLOBAL status LIKE 'Innodb_page_size';
     16384 B/1024 = 16KB
  ```
  [2] 索引结构的节点大小被设计为一个页的大小;

  每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O;

  再看 非叶子节点，假设主键ID （比如15）为BIGINT类型，那么长度就是8B，指针大小在InnoDB源码中为6B，那么一共就是14B，那么一个非叶子节点就可以存储16K/14=16*1024/14=1170 个（主键+指针）
   
   <font color='red'>目的: 让非叶子节点  可以存储更多的元素，也就有更多的分叉，树的高度就会相对低，查询一个数据就会更快，IO次数也就更少。</font>

  [3] 假设B+Tree的高度为3;

      - 第一层也就是root节点 ，可以存储 1170个元素;

      - 第二层可以存储 1170*1170 个元素

      - 第三层因为是叶子节点，叶子节点上存储着data（1：索引所在行的磁盘文件指针 2：索引所在行的整个数据）；
      我们假设data+主键索引 一共的大小为1K,那么一个叶子节点就可以存储16K/1=16个节点;

      对于高度h为3的一棵B+Tree来讲，一共可以存储1170*1170*16=21902400 个元素（千万级表的存储高度只需要3!）
  [4] 由以上3步骤我们可以看出，B+Tree的低高度高容量的特性;

  B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。
  
  # MySQL索引实现
  ## MyISAM索引实现
  ### 1.MyISAM索引的原理图
  MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是<font color='red'>**数据记录的地址**</font>。下图是MyISAM索引的原理图:

 ![](/about/media/pic/myisam索引原理图.png)
  
  ### 2.MyISAM辅助索引
  在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，<font color='red'>**而辅助索引的key可以重复**</font>。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：
  ![](/about/media/pic/myisam辅助索引原理图.png)

  ### 3.MyISAM索引总结
  ```
    同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。

     MyISAM的索引方式也叫做“非聚集”(非聚簇)的，之所以这么称呼是为了与InnoDB的聚集索引区分。
  ```

## InnoDB索引实现
### 1.InnoDB索引原理图
InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
 ![](/about/media/pic/innodb索引原理图.png)

叶节点包含了完整的数据记录。这种索引叫做<font color='red'>**聚集索引(聚簇索引)**)</font>。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。
### 2.InnoDB辅助索引原理图
与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，定义在Col3上的一个辅助索引：
 ![](/about/media/pic/innodb辅助索引原理图.png)
 - 聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。
 - 了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。









