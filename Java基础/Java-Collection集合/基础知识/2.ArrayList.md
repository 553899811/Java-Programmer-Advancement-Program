<!-- GFM-TOC -->
* [ArrayList介绍](#arraylist介绍)
    * [1. ArrayList 简介](#1-arraylist-简介)
       * [1.1 实现细节](#11-实现细节)
         * [1.1.1 实现和继承关系](#111-实现和继承关系) 
         * [1.1.2 底层实现](#112-底层实现)
           * [1.1.2.1 transient关键字](#1121-transient关键字)
           * [1.1.2.2 构造器](#1122-构造器)
           * [1.1.2.3 扩容机制](#1123-扩容机制)
    * [2. ArrayList高级特性](#2-arraylist高级特性)
      * [2.1 线程不安全](#21-线程不安全)
         * [2.1.1 解决方案](#211-解决方案)
      * [2.2 fail-fast问题](#22-fail-fast问题)
         * [2.2.1 简介](#221-简介)
         * [2.2.2 fast-fail示例](#222-fast-fail示例)
         * [2.2.3 fail-fast原理](#223-fail-fast原理)
   
<!-- GFM-TOC -->
# ArrayList介绍
## 1. ArrayList 简介
```
   ArrayList 是一个数组队列,动态数组(动态扩容); 允许添加null元素;
```
### 1.1 实现细节
```
  public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
#### 1.1.1 实现和继承关系
   - **继承** 抽象类**AbstractList**,实现了List;List是一个数组队列,提供了相关的添加,删除,修改,遍历等功能;
   - **实现** RandomAccess接口,即提供了随机访问功能;RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。
   - **实现** Cloneable接口,即覆盖了clone()方法,能被克隆;
   - **实现** java.io.Serializable 接口,支持序列化,能通过序列化去传输;
  
#### 1.1.2 底层实现
```
    transient Object[] elementData; // non-private to simplify nested class access
```
 - 实质上是 **Object数组** 构成;
##### 1.1.2.1 transient关键字
   - 为何会有transient关键字,何时会用到它?
   ```
     一个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。
   ```
   - transient 关键字使用总结</br>
    [transient博文](https://www.cnblogs.com/lanxuezaipiao/p/3369962.html#top)</br>
    [深入学习序列化](http://mp.weixin.qq.com/s/MGCwOELDN8lIlvfTwhPAbQ)
##### 1.1.2.2 构造器
 - 空构造器
   - 默认初始化容量:10
```
   /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;
```
```
 /**
     * Constructs an empty list with an initial capacity of ten.
     */
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
    }
```
   - **不同之处**
 ```
   JDK 1.7和JDK1.8默认构造器发生了变化,但是默认初始化容量都是10;具体实现,暂不深究;
 ```
  - int 参数构造器
    - 参数为一个int 整数; 
```
   /**
     * 给定一个容量,然后创建相对应大小的Objec[]数组;
     *
     * Constructs an empty list with the specified initial capacity.
     *
     * @param  initialCapacity  the initial capacity of the list
     * @throws IllegalArgumentException if the specified initial capacity
     *         is negative
     */
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        }
    }
```
 - 集合参数构造器
   - 参数为Collection集合下具体实现类;
```
  /**
     * Constructs a list containing the elements of the specified
     * collection, in the order they are returned by the collection's
     * iterator.
     *
     * @param c the collection whose elements are to be placed into this list
     * @throws NullPointerException if the specified collection is null
     */
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();
        if ((size = elementData.length) != 0) {
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elementData.getClass() != Object[].class)
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            // replace with empty array.
            this.elementData = EMPTY_ELEMENTDATA;
        }
    }
    举栗子说明:
     LinkedList<Object> linkedList = new LinkedList<>();
        linkedList.add(1);
        linkedList.add(2);
        linkedList.add(3);
        ArrayList<Object> objects = new ArrayList<>(linkedList);
        for (Object object : objects) {
            System.out.println(object);
        }
    // 1 2 3
```
##### 1.1.2.3 扩容机制
 - 扩容变化:
   - 每次扩容 50% , 亦新容量为旧容量的1.5倍
```
  思考下,什么时候会扩容? 肯定是装不下东西的时候会扩容哦,所以我们从添加元素 方法开始;
```
 **[1]** add 方法 
   - add(E e)方法, 默认添加到尾部

```
 [1] add方法添加元素
  public boolean add(E e) {
        //在添加元素前调用ensureCapacityInternal方法,进行容量检验,看能否装得下;
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
    
 [2] ensureCapacityInternal检验容量
  private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }
    
 [3]实质检验方法 ensureExplicitCapacity
 private void ensureExplicitCapacity(int minCapacity) {
        // modCount 用来记录 ArrayList 结构发生变化的次数，因为每次在进行 add() 和 addAll() 时都需要调用 ensureCapacity()，因此直接在 ensureExplicitCapacity()中对 modCount 进行修改
        modCount++;
        // overflow-conscious code
        // 看下
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
  [4]校验完毕之后,进入到扩容grow()方法中
   /**
     * Increases the capacity to ensure that it can hold at least the
     * number of elements specified by the minimum capacity argument.
     *
     * @param minCapacity the desired minimum capacity
     */
    private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        // 新容量是旧容量的1.5倍,即扩容 50%;
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```
 - add(int index,E element) 在特定位置插入元素
```
  System.arraycopy(elementData, index, elementData, index + 1,
                         size - index);
  具体代码不贴入,关键点在于当一个元素被插入后,之后的元素都会被整体后移一个单位长度,会涉及到整体复制,性能消耗大,这也是和LinkedList最本质的区别;
  ArrayList查询便捷,LinkedList删除便捷;
```
## 2. ArrayList高级特性
### 2.1 线程不安全
```
  ArrayList是不安全的,我们举一个例子说明下:
  //添加元素源码
  public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
  一个 ArrayList 在添加一个元素的时候，它可能会有两步来完成:
  1.在elementData[size]的位置上存放此元素;
  2.增大size的值;
  其本质上来讲是size++不是一个原子操作导致的线程安全问题;
  [1]在单线程环境下,如果size=0,添加一个元素后,此元素在位置0,而且size=1;
  [2]在多线程环境下,比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。
    线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0（注意哦，我们假设的是添加一个元素是要两个步骤哦，
    而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。
    然后线程A和线程B都继续运行，都增加 Size 的值; 
```
#### 2.1.1 解决方案
 - 使用synchronized关键字,锁定临界区;
 - 使用 **Collections.synchronizedList()**,使用方法如下:
```
  
```
 - 使用JUC中的 CopyOnWriteArrayList
```
  具体的使用之后会在多线程模块中具体分析并发容器的数据结构;
```
### 2.2 fail-fast问题
#### 2.2.1 简介
```
  fail-fast 机制是java集合(Collection)中的一种错误机制,当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。
例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。
```
[fast-fail博文](http://wangkuiwu.github.io/2012/02/04/collection-04-fail-fast/)
#### 2.2.2 fast-fail示例
```
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
/**
 * @author littledream1502@gmail.com
 * @date 2018/3/14
 * @desc
 */
public class FastFail {
    private static List<String> list = new ArrayList<>();

    public static void main(String[] args) {
        new ThreadOne().start();
        new ThreadTwo().start();
    }

    private static void printAll() {
        System.out.println("");
        String value = null;
        //获取容器的迭代器;
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            String next = iterator.next();
            System.out.println(value + ", ");
        }
    }

    private static class ThreadOne extends Thread {
        public void run() {
            int i = 0;
            while (i < 6) {
                list.add(String.valueOf(i));
                printAll();
                i++;
            }
        }
    }

    private static class ThreadTwo extends Thread {
        public void run() {
            int i = 10;
            while (i < 16) {
                list.add(String.valueOf(i));
                printAll();
                i++;
            }
        }
    }
}
---------------------------------------------------
Exception in thread "Thread-0" java.util.ConcurrentModificationException
  at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)
  at java.util.ArrayList$Itr.next(ArrayList.java:859)
Disconnected from the target VM, address: '127.0.0.1:11463', transport: 'socket'
  at com.zhangyong.Solution.FastFail.printAll(FastFail.java:25)
  at com.zhangyong.Solution.FastFail.access$300(FastFail.java:12)
  at com.zhangyong.Solution.FastFail$ThreadOne.run(FastFail.java:36)
```
#### 2.2.3 fail-fast原理
 - ArrayList是如何抛出ConcurrentModificationException异常的呢?
```
  ConcurrentModificationException是在操作Iterator时抛出的异常。我们先看看Iterator的源码。
  ArrayList的Iterator是在父类AbstractList.java中实现的。
  // AbstractList中唯一的属性
    // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1
    protected transient int modCount = 0;

    // 返回List对应迭代器。实际上，是返回Itr对象。
    public Iterator<E> iterator() {
        return new Itr();
    }

    // Itr是Iterator(迭代器)的实现类
    private class Itr implements Iterator<E> {
        int cursor = 0;

        int lastRet = -1;

        // 修改数的记录值。
        // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount；
        // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等；
        // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
        int expectedModCount = modCount;

        public boolean hasNext() {
            return cursor != size();
        }

        public E next() {
            // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等；
            // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。
            checkForComodification();
            try {
                E next = get(cursor);
                lastRet = cursor++;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        public void remove() {
            if (lastRet == -1)
                throw new IllegalStateException();
            checkForComodification();

            try {
                AbstractList.this.remove(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
    从中，我们可以发现在调用 next() 和 remove()时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。
```
 - ArrayList中modCount值何时被修改
```
  要搞明白 fail-fast机制，我们就要需要理解什么时候“modCount 不等于 expectedModCount”！
从Itr类中，我们知道 expectedModCount 在创建Itr对象时，被赋值为 modCount。通过Itr，我们知道：expectedModCount不可能被修改为不等于 modCount。所以，需要考证的就是modCount何时会被修改。
```
 - ArrayList中的具体实现
```
  [1] add方法:
  public boolean add(E e) {
       // 修改modCount
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
  }
  private void ensureCapacityInternal(int minCapacity) {
        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
    }

    private void ensureExplicitCapacity(int minCapacity) {
        modCount++;

        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
  [2]remove方法
  public E remove(int index) {
        rangeCheck(index);

        modCount++;
        E oldValue = elementData(index);

        int numMoved = size - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--size] = null; // clear to let GC do its work

        return oldValue;
  }
  总结:从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。
  接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下：
(01) 新建了一个ArrayList，名称为arrayList。
(02) 向arrayList中添加内容。
(03) 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。
(04) 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。
(05) 这时，就会产生有趣的事件了。
    在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。
在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！
“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。
[总结]
至此，我们就完全了解了fail-fast是如何产生的！
即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。
```



   
  
  



    
