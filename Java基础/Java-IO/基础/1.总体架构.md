* [IO 概述](#io-概述)
    * [1. 字节流](#1-字节流)
        * [1.1 字节流层次结构图](#11-字节流层次结构图)
        * [1.2 常用的字节流类](#12-常用的字节流类)
        * [1.3 字节流读写](#13-字节流读写)
    * [2. 字符流](#2-字符流)
    * [3. 缓冲流](#3-缓冲流)
    * [4. 对象的序列化](#4-对象的序列化)
* [NIO](#nio)
   * [1. IO与NIO的区别](#1-io与nio的区别)
        * [1.1 面向流与面向缓冲](#11-面向流与面向缓冲)
        * [1.2 阻塞与非阻塞](#12-阻塞与非阻塞)
        * [1.3 Selectors(选择器)](#13-selectors)
    * [2. NIO详解](#2-nio详解)

 1.3 Selectors(选择器)

# IO 概述
![IO流](https://github.com/553899811/NewBie-Plan/blob/master/Java基础/Java-IO/img/01.jpg)

## 1. 字节流
### 1.1 字节流层次结构图
![输入输出流层次结构图](https://github.com/553899811/NewBie-Plan/blob/master/Java基础/Java-IO/img/1.jpg)

### 1.2 常用的字节流类
- InputStream/OutPutStream ——字节流基类
- FileInputStream/FileOutputStream ——处理文件类型
- ByteArrayInputStream/ByteArrayOutputStream——字节数组类型
- DataInputStream/DataOutputStream——装饰类
- BufferedInputStream/BufferedOutputStream——缓冲流

### 1.3 字节流读写
- 字节流读写步骤（文件复制）
```
    //封装数据源
    FileInputStream fin = new FileInputStream("F:\\a.png");
    //封装目的地
    FileOutputStream fou = new FileOutputStream("F:\\a2.png");
    //读写数据
    byte[] bytes = new byte[1024];
    int len = 0;
    while ((len=fin.read(bytes))!=-1){
        fou.write(bytes, 0, len);
    }
    //释放资源
    fin.close();
    fou.close();
```
- 字节流读取文件信息
```
    FileInputStream fin = new FileInputStream("f:\\b.txt");
    byte[] bytes = new byte[1024];
    fin.read(bytes,0,bytes.length);
    String str = new String(bytes);
    System.out.println(str);
    fin.close();
```
- 注1： 字节流操作字符串需把字符串转byte数组，需使用String类的getBytes()方法
```
    FileOutputStream out = new FileOutputStream(new File("f:\\b.txt"),true);
    out.write("hello".getBytes());
    out.close();
```
- 注2：换行和追加写数据
```
//换行输出  windows:\r\n  linux:\n  mac:\r
out.write("\r\n".getBytes());
//追加数据  构造方法第二个参数传true
FileOutputStream fos = new FileOutputStream("c.txt",true);
```
## 2. 字符流
- 字符流demo
```
    FileReader fr = new FileReader("d:\\林.txt");
    FileWriter fw = new FileWriter("d:\\窗.txt");
    
    char[] chs = new char[1024];
    int len;
    while((len=fr.read(chs))!=-1) {
    	fw.write(chs, 0, len);
    }
    fw.close();
    fr.close();
```
- 编码和解码

编码就是把字符转换为字节，而解码是把字节重新组合成字符。

不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符，所以操作字符需用到转换流，把字符转化为字节操作。

- 转换流
```
转换流其实就是一个字符流。
转换流 等于 字节流 + 编码表。

- 转换流的构造方法(charsetName例： “UTF-8”)
    public OutputStreamWriter(OutputStream out)//根据默认编码把字节流的数据转换为字符流
    public OutputStreamWriter(OutputStream out,String charsetName)//根据指定编码把字节流数据转换为字符流
  
    public InputStreamReader(InputStream in)
    public InputStreamReader(InputStream in,String charsetName)
```
- 转换流Demo
```
    FileOutputStream out = new FileOutputStream("f:\\b.txt", true);
	OutputStreamWriter osw = new OutputStreamWriter(out,"UTF-8");
	osw.write("你好");
	osw.close();
	System.out.println("------------------------");
	FileInputStream in = new FileInputStream("f:\\b.txt");
	InputStreamReader isr = new InputStreamReader(in,"UTF-8");
	int ch;
	while((ch=isr.read())!=-1) {
		System.out.println((char)ch);
	}
	isr.close();
```
- 字节流和字符流的区别
```
1. 字节流读取的时候，读到一个字节就返回一个字节； 字符流使用了字节流读到一个或多个字节（中文对应的字节数是两个，在UTF-8码表中是3个字节）时。先去查指定的编码表，将查到的字符返回。
2. 字节流可以处理所有类型数据，如：图片，MP3，AVI视频文件，而字符流只能处理字符数据。只要是处理纯文本数据，就要优先考虑使用字符流，除此之外都用字节流。
```

## 3. 缓冲流
以Buffered开头的类通常都为缓存流，例如BufferedReader，BufferedOutputStream等。缓存流读入一个字节/字符，先不输出，等凑足了缓冲的最大容量（自己定义的byte[]/char[]的最大容量）后一次性写出，从而提高了工作效率。该类的构造方法都需传入一个字节流、字符流的对象，以为其只提供缓冲，不负责具体的读写。

- 缓冲流类
```
BufferedReader：readLine 方法用于高效读取一行字符串
BufferedWriter：newLine 换行
BufferedInputStream、BufferedOutputStream
```
- Demo
```
    ArrayList<String> array = new ArrayList<String>();
	array.add("hello");
	array.add("world");
	BufferedWriter bw = new BufferedWriter(new FileWriter("array.txt"));
	
	for(String s : array) {
		bw.write(s);
		bw.newLine();
		bw.flush();
	}
	bw.close();
```
## 4. 对象的序列化
- 定义
```
序列化：  把Java对象转换为字节序列的过程(ObjectOutputStream.writeObject())。
反序列化：把字节序列恢复为Java对象的过程(ObjectInputStream.readObject())。
```
- 用途
```
对象的序列化主要有两种用途：
1. 一般情况下Java对象的声明周期都比Java虚拟机的要短，实际应用中我们希望在JVM停止运行之后能够持久化指定的对象，这时候就需要把对象进行序列化之后保存。（持久化对象） 
2. 因为数据只能够以二进制的形式在网络中进行传输，因此当把对象通过网络发送出去之前需要先序列化成二进制数据，在接收端读到二进制数据之后反序列化成Java对象。（网络传输对象）
```
- 意义
```
客户端访问了某个能开启会话功能的资源，web服务器就会创建一个与该客户端对应的HttpSession对象，每个HttpSession对象都要站用一定的内存空间。如果在某一时间段内访问站点的用户很多，web服务器内存中就会积累大量的HttpSession对象，消耗大量的服务器内存，即使用户已经离开或者关闭了浏览器，web服务器仍要保留与之对应的HttpSession对象，在他们超时之前，一直占用web服务器内存资源。

web服务器通常将那些暂时不活动但未超时的HttpSession对象转移到文件系统或数据库中保存，服务器要使用他们时再将他们从文件系统或数据库中装载入内存，这种技术称为Session的持久化。

将HttpSession对象保存到文件系统或数据库中，需要采用序列化的方式将HttpSession对象中的每个属性对象保存到文件系统或数据库中；将HttpSession对象从文件系统或数据库中装载如内存时，需要采用反序列化的方式，恢复HttpSession对象中的每个属性对象。所以存储在HttpSession对象中的每个属性对象必须实现Serializable接口

番外：Session的持久化的作用
1.提高服务器内存的利用率，保证那些暂停活动的客户端在会话超时之前继续原来的会话
2，在多台web服务器协同对外提供服务的集群系统中，使用Session的持久化技术，某台服务器可以将其中发生改变的Session对象复制给其他服务器。保证了在某台服务器停止工作后可以由其他服务器来接替它与客户端的会话
3，在一个web应用程序重启时，服务器也会持久化该应用程序中所有HttpSession对象，保证客户端的会话活动仍可以继续。
```
- 注
```
1、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）

2、序列化并不保存静态变量。

3、Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。

4、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。
```
- Demo
```
//1.定义一个User类，用于序列化以及反序列化，包含name/age/birthday属性，及getter、setter、toString方法，代码略；
//2.定义SerializableDemo类，对User进行序列化及反序列化
public class SerializableDemo {
 
    public static void main(String[] args) {
        //Initializes The Object
        User user = new User();
        user.setName("hollis");birthday
        user.setAge(23);
        user.setBirthday(new Date());
 
        //序列化持久化对象
        ObjectOutputStream oos = null;
        try {
            oos = new ObjectOutputStream(new FileOutputStream("tempFile"));
            oos.writeObject(user);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(oos);
        }
 
        //反序列化，并得到对象
        File file = new File("tempFile");
        ObjectInputStream ois = null;
        try {
            ois = new ObjectInputStream(new FileInputStream(file));
            User newUser = (User) ois.readObject();
            System.out.println(newUser);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } finally {
            IOUtils.closeQuietly(ois);
            try {
                FileUtils.forceDelete(file);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
 
    }
}
```

# NIO
## 1. IO与NIO的区别
```
IO                NIO
面向流            面向缓冲
阻塞IO            非阻塞IO
无                选择器
```
### 1.1 面向流与面向缓冲
```
Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。

IO面向流意味着一次处理一个字节数据，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。

NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。
```
### 1.2 阻塞与非阻塞
```
Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 

Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。

非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。
```
### 1.3 Selectors
```
Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。
```
## 2. NIO详解
